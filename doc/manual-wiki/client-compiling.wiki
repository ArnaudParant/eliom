=Compiling client-server Eliom applications

The build process for client-server Eliom applications is rather
tricky. To ease development of such application, the eliom's
distribution contains some helpers scripts and Makefiles.

<<outline depth="2">>

==@@id="compilation"@@ Compilation overview

Here is first of all a small overview of the compilation
process of a (single file) Eliom program. The source code of an Eliom
application is stored in a file with the extension ##.eliom##. In this
manner, it is detected by the Eliom compilers, ##eliomc## and ##js_of_eliom##.
The compilation of an eliom program is carried out in three steps.

First, necessary type information of the server program is extracted
from the source code by ##eliomc -infer##. This information is
necessary for the actual compilation of the client and server
program. It is typically stored in a file ##_server/program.type_mli##
for an Eliom module in a file ##program.eliom##.

Secondly, the server program (or rather, the library to be dynamically
loaden into the Ocsigen server) is compiled by the program ##eliomc -c##.
It filters the source code for the parts relevant to the server
and compiles it against the libraries available server. The resulting
bytecode object file is stored in ##_server/program.type_mli## by default.

Thirdly, the client program is compiled by ##js_of_eliom##. It filters
the source code for the parts relevant for the client program and
compiles it against the libraries available for client.  The
program ##js_of_eliom -c## creates a bytecode object file (stored
in ##_client/program.cmo## by default) and ##js_of_eliom -o program.js##
is used to actually compile and link the //JavaScript// program to run on
the client.

{{site:eliom/compilation.png|The Compilation process}}

So much for the compilation process, here comes what you gain from
Eliom for the integrated development of client/server applications.


==Using {{{eliomc}}} and {{{js_of_eliom}}}

The easiest way to build a client-server Eliom application is to used
the scripts {{{eliomc}}} and {{{js_of_eliom}}}. Those scripts are
basic wrappers around {{{ocamlfind}}}, {{{ocamlc}}} and
{{{js_of_ocaml}}}.

You can compile your application with the following two commands:

{{{
eliomc -a -o appl.cma server_module.ml appl.eliom ...
js_of_eliom -o appl.js client_module.ml appl.eliom ...
}}}

The first command compile the server-specific part of the
application. The second one compile the client-specific part. Each
command accept multiple {{{.ml}}} and {{{.eliom}}} files.

Temporary files will be written in the {{{_server}}} and
{{{_client}}} directory. Those directory may be changed with command
line option of the environment variable {{{ELIOM_SERVER_DIR}}} and
{{{ELIOM_CLIENT_DIR}}}.

Those commands accepts the same set of arguments as {{{ocamlc}}}, plus
the following specific options:

* {{{-package}}} is the same to the {{{ocamlfind}}} option.
* {{{-predicates <p>}}} is the same to the {{{ocamlfind}}} option.
* {{{-dir <dir>}}} set default directory for temporary files.
* {{{-jsopt <opt>}}} pass {{{opt}}} to the {{{js_of_ocaml}}} compiler **{{{js_of_eliom}}} only**

If you want to use the native version of ocsigen server, you may
replace {{{eliomc}}} by {{{eliomopt}}}.

==Using a Makefile based on {{{eliomc}}} and {{{js_of_eliom}}}

The eliom distribution also contains a sample Makefile based on
{{{eliomc}}} and {{{js_of_eliom}}} with proper dependencies
handling. You will find it the {{{eliom/src/files/}}} directory.

Just adjust the variables found at the top of the Makefile, then run:

{{{
make depend
make
}}}

The sample Makefile use an experimental wrapper around {{{ocamldep}}}
to generate the dependencies, called {{{eliomdep}}}. Please note that
{{{eliomdep}}} is still incomplete: it does not handle dependency
towards {{{.eliom}}} file. It generate however correct dependy toward
{{{.ml}}} files from an {{{.eliom}}} file.

<<|==Using {{{ocamlbuild}}}

We do not support ocamlbuild sofar

<<wip|TODO>>

>>

==@@id="implementation"@@ Implementation of the language extensions

Here is some details on the implementation of the <<a_manual
chapter="eliomc"|language extensions in Eliom>>.  To investigate this
in more detail, it is advisable to dump the source code for the server
or client program with with ##eliomc -c -infer## or ##js_of_eliom -c
-infer## respectively, and to refer to the API of the generated
functions in ##Eliom_service.Syntax_helpers## on the server
and ##Eliom_client.Syntax_helpers## on the client.

=== Client values

For each occurrence of a client value ##{typ{ exp }}## with injected
variables ##v_1##, ..., ##v_n## in the source code, i.e. static
occurrence, at a location ##p##, the syntax extension registers
with ##p## as the closure ID a function

<<code language="ocaml"|
       fun (v'_1, ..., v'_n) -> exp'
>>

where ##exp'## is ##exp## with occurrences of ##%v_i## replaced
by ##v'_i## where all ##v'_i## are free in ##exp##.

When a client value is then created dynamically, a <<a_api|type
Eliom_lib_base.client_value_datum>> is registered to be sent to the
client with the {!Eliom_lib_base.global_data} or
{!Eliom_lib_base.request_data} respectively. It contains the closure
ID, an instance ID (unique per client value), and the tuple of
injected values (sometimes known as ##args##).

On the client side, that client value datum will be used to register
an actual client value: A client closure is obtained by the specific
closure ID, and it is applied on the tuple of injected
values. Finally, the result is registered in a client value table for
that specific closure ID and instance ID.

The representation of a client value on the server side is
comprised just of the respective closure ID, and the instance
ID. When it reaches the client, it is unwrapped to the concrete
value by looking it up in the client value table mentioned before.


=== Injection

The usage of an injection registers the value under a specific
identifier on the server side. All injections are sent to the client
with the initial request as a table mapping those identifiers to
(untyped) values.

On the client side, at the beginning of each client/shared
section, all novel injections are registered in a global table of
injections. This must be done post-hoc because client values are
unwrapped late.

The syntax extensions then generates for an injection just a lookup in
that global table for its identifer. Type constraints are generated
from the syntax extension.
