=@@id="server_generating_html"@@Generating HTML pages=

Ocsigen provides several ways to generate and type HTML5 pages.

* The default technique to produce HTML5 pages using Eliom is the
   <<a_api | module Eliom_content.Html5.F >> and
   <<a_api | module Eliom_content.Html5.D >>
   module. It is the only one supported for client side Eliom programs.
   This module provides a typing based on OCaml's polymorphic variants,
   which ensures at compile time, that the pages you will generate will
   respect the recommendations of the W3C (or be very close).
* It is also possible to use a syntax extension to write your pages with the
  usual HTML syntax. This solution is also typed with polymorphic variants
  and is compatible with the previous one.
* You can also choose to generate untyped html as text.

=== Html5 ===

The types in OCaml closest to XML types are //polymorphic variants//.
Ocsigen uses them to provide a module with very good HTML5 typing.
The full documentation is available
<<a_api text="in the TyXML documentation" project="tyxml" | module Html5.M >>.

=== HTML syntax extension===

Ocsigen also has a syntax extension for OCaml that allows you to write
pages using HTML syntax (but you are free not to use it).  This is
convenient for example if you want to include (parts of) HTML pages
that have been created by third party.  To choose actual
XML-implementation you have to provide a module named ##Html5##
(or ##Svg## respectively):

For example, the following code:
<<code language="ocaml"|
module Html5 = Html5.M (* NB this is TyXML's Html5; could also be Eliom_content.Html5.F *)

<< <html>
     <head><title></title></head>
     <body><h1>plop</h1></body>
   </html> >>
>>
is a caml value of type {{{Html5_types.html Html5.M.elt}}}.

To compile a module containing this syntax, you need the camlp4 preprocessor:
{{{
ocamlc -I /path_to/ocsigen/
 -pp "camlp4o /path_to/ocsigen/xhtmlsyntax.cma -loc loc"
 -c your_module.ml
}}}

You can insert OCaml expressions of type {{{'a Html5.M.elt}}} inside
html using {{{$...$}}}, like this:

<<code language="ocaml"|
let oc = << <em>Ocsigen</em> >> in
<< <p>$oc$ will revolutionize web programming.</p> >>
>>

<<wip| remove \ before $, _ in code, everywhere in pdf version!!!!!!!!!! >>

You can insert OCaml expressions of type string inside html
using ##$str:... $##, like this:

<<code language="ocaml"|
let i = 4 in
<< <p>i is equal to $str:string_of_int i$</p> >>
>>

If you want to use a dollar in your page, just write it twice.

You can write a list of HTML5 expressions using the syntax {{{<:xmllist<...>>}}}, for example:
<<code language="ocaml"|
<:html5list< <p>hello</p> <div></div> >>
>>
Here are some other examples showing what you can do:
<<code language="ocaml"|
<< <ul class=$ulclass$ $list:other_attrs$>
     $first_il$
     $list:items$
   </ul> >>
>>

Warning: lists antiquotations are allowed only at the end (before a
closing tag). For example, the following is not valid:

<<code language="ocaml"|
<< <ul $list:other_attrs$ class=$ulclass$>
     $list:items$
     $last_il$
   </ul> >>
>>

The syntax extension is not allowed in patterns for now.

//Warning:// The two syntaxes are not equivalent for typing.  Using
the syntax extension will do less checking.  For example the following
code is accepted but not valid regarding HTML5 standard (because
<<span class="code"|<head>>> must contain a title):

<<code language="ocaml"|
  << <html>
     <head></head>
     <body><h1>plop</h1></body>
   </html> ~>>
>>

We recommend you use the functions from <<a_api project="tyxml" |
module Eliom_content.Html5.D>>, as you will (almost) always get valid
HTML5. Use the syntax extension for example to enclose already created
pieces of HTML, and check your pages validity with the
[[http://validator.w3.org/| W3C validator]].


===Text HTML===

The last possibility is to use untyped HTML. Just build strings
containing your pages. Here is an example:

<<code language="ocaml"|
let coucoutext =
  Eliom_registration.Html_text.register_service
    ~path:["coucoutext"]
    ~get_params:Eliom_parameter.unit
    (fun () () ->
      Lwt.return
        ("<html>n'importe quoi "^
         (Eliom_content.Html_text.a coucou "clic" ())^
         "</html>"))
>>

===@@id="custom_data"@@Custom data for HTML5===

Eliom provides a type-safe interface for using HTML5's custom data, <<a_api | module
Eliom_content.Html5.Custom_data>>.

==== Creation ====
Custom data may be created either from string-conversation functions by <<a_api | val
Eliom_content.Html5.Custom_data.create>>

<<code language="ocaml"|
open Eliom_content
type my_int_data =
  Html5.Custom_data.create ~name:"my_int" ~of_string:int_of_string ~to_string:string_of_int ()
>>

or by a Json-deriving type <<a_api | val Eliom_content.Html5.Custom_data.create_json>>

<<code language="ocaml"|
{shared{
  type coord = { x : int; y : int; } deriving (Json)
  let coord_data =
    Html5.Custom_data.create_json ~name:"coord" Json.t<coord>
}} >>

==== Injecting ====

Custom data can be injected into HTML5-trees of type <<a_api
project="eliom"|type Eliom_content.Html5.elt>> by the function <<a_api
project="eliom"|val Eliom_content.Html5.Custom_data.attrib>>:

<<code language="ocaml"|
  div ~a:[Html5.Custom_data.attrib coord_data {x = 100; y = 200}] []
>>

NB, HTML5 gives no restriction on the usage of custom data, any custom data can
may be added to //any// HTML5 element.

==== Reading/writing the DOM ====

On the client side, custom data can be read from and written to JavaScript DOM
elements of type <<a_api project="js_of_ocaml"|class type Dom_html.element>>.

Custom data can be read from a DOM-element with the function
<<a_api subproject="client"|val Eliom_content.Html5.Custom_data.get_dom>>.
If no respective custom data attribute can be found in the element
 * the ##default## value from creating the custom data is returned, if any, or
 * an exception ##Not_found## is raised, otherwise.

The custom data of a DOM-element can be set with the function
<<a_api subproject="client"|val Eliom_content.Html5.Custom_data.set_dom>>.

<<code language="ocaml"|
  {client{
    fun (div : Dom_html.element Js.t) ->
      let i = Html5.Custom_data.get_dom div coord_data in
      debug "{x=%d; y=%d}" i.x i.y;
      Html5.Custom_data.set_dom div coord_data { x = i.x + 1; y = i.y - 1 }
  }}
>>

==== Default value ====
If a custom data is created with the optional argument ##default##, calls to
<<a_api subproject="client" | val
Eliom_content.Html5.Custom_data.get_dom>> return that instead of throwing an
exception [Not_found].

<<code language="ocaml"|
  let coord_data' =
    Html5.Custom_data.create_json ~name:"coord" default:{x=0;y=0;} Json.t<my_data>
>>
