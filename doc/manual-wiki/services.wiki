
= Services =

<<outline depth="2"| <<header| =Table of contents= >> >>

== Introduction ==

<<outline depth="2" >>

Services are entry points to your Web site. In general, services are
attached to an URL and generate a Web page ; but there is also, for
example, services identified by specific GET or POST parameters or
services representing redirections.

A service is composed of:

* some identification data, allowing Eliom to choose which service
  should answer a incoming request;
* a service handler that will generate the answer.

<<paragraph| Service creation >>

Operation on service in Eliom are allowed by values of type <<a_api |
type Eliom_services.service >>, as returned by one of the many
functions provided to create services. The most common service
creation function is <<a_api | val Eliom_output.HTML5.register_service
>>. It allows to create a service attached to a given path that may
expect some GET parameters and that return some HTML5 contents using
the TyXML library.

<<paragraph| Registrable service >>

The service creation could be split in two steps:

* create a value of type service, e.g. using <<a_api | val
  Eliom_services.service >>
* register a service handler, e.g. using <<a_api | val
  Eliom_output.HTML5.register >>


This chapter focus on value of type {{{service}}}, see chapter
<<a_manual chapter="outputs"| Writing service handlers>> for more
information on service registration.

Some services can be registered multiple times with different options.
This allows for example to choose between different handlers when the
request is done in a particular session or protocol (HTTP or HTTPS).

<<div style="font-style: italic;"| Warning: in this manual, we use the
term //service// both to denote a value of type {{{service}}} --that
only contains some location information about a service--, or a fully
//registred// service, that is also composed of a service handler. In
case of ambiguities, we will use {{{service}}} --in green monotype--
to designate a value of type {{{service}}}.

>>

<<paragraph| Creating link and forms >>

Value of type {{{service}}} may be used to create links and forms
towards a service, using for example the function <<a_api | val
Eliom_output.Html5.a >>. See chapter <<a_manual
chapter="links"|Creating links and forms>> for more information.

<<paragraph| Unegistrable service >>

Some specific values of type {{{service}}} aren't associated to any
service handlers. Such value are called //unregistrable services//,
and represents for example, links towards external site ot registrable
service pre-applied to some parameters. This allows to use
{{{service}}} consistently for creating links. See chapter <<a_manual
chapter="services" fragment="unregistrable_services"| Unregistrable
services >>.


== Registrable services ==

<<outline depth="2" >>


=== Service identification ===

Eliom has a sophisticated //service identification mechanism// to
choose the service handler to be executed --given an incoming
request-- with respect to many criteria:

* the path of the requested URL,
* the names of the (GET or POST) parameters,
* some internal (GET or POST) parameter, added automatically,
* the HTTP method,
* the session the client belongs to (or client side process, or session group),
* ...

Eliom provides three main kind of services, that differs by the subset
of these criteria used to identified them:

* <<a_manual chapter="services" fragment="regular_services" | Regular services>>
  are the main entry points of sites.
  They are identified by the path of the URL and by (GET or POST) parameters.
  They correspond to classical URLs, and will last forever once registered.
* <<a_manual chapter="services" fragment="attached_coservices" | Attached coservices>>
  are services that share their
  location (URL) with a regular service (called //fallback//).
  They are identified by the path of the URL and a special parameter
  (added automatically by Eliom). They can be created dynamically. When
  an attached coservice is not available anymore (timeout, session closed,~ ...)
  it fallbacks to the corresponding regular service.
* <<a_manual chapter="services" fragment="non-attached_coservices" | Non-attached coservices>>
  are coservices only identified by a special parameter
  whatever be the path and other parameters in the URL.
  They are used to implement some behaviour that should not be attached to
  a particular URL. A link to a non-attached coservice will go to the current
  URL with just an additional special parameter.
  It is useful when you want the same link or form on
  several pages (for example a connection box) but you don't want to
  go to another URL. Non-attached coservices are often used with
  <<a_manual chapter="outputs" fragment="actions" |actions>>.


==== Path ====

Paths are represented in Eliom by a list of string. For example:

<<span class="code"|["foo"; "bar"]>> corresponds to the URL
<<span class="code"|foo/bar>>.  \\
<<span class="code"|["dir"; ""]>> corresponds to the URL <<span class="code"|dir/>>
(that is: the default page of the directory <<span class="code"|dir>>).   \\
The empty list <<span class="code"|[]>> is equivalent to <<span class="code"|[""]>>.\\

//Warning://
You cannot create a service on path <<span class="code"|["foo"]>>
(URL <<span class="code"|foo>>, without slash at the end)
and another on path <<span class="code"|["foo";"bar"]>>
(URL <<span class="code"|foo/bar>>) because <<span class="code"|foo>> can not be
both a directory and a file.
Be also careful not to use a path as a directory with
Eliom, if it is a file for Staticmod (and vice versa).

//Warning://
<<span class="code"|["foo";"bar"]>> is not equivalent to
<<span class="code"|["foo/bar"]>>.
In the latter, the "/" will be encoded in the URL.\\



==== Service parameters ====

A service is partially identified by the name of its GET and POST
parameters.

The parameters of services are specified using the {{{~get_params}}}
and {{{~post_params}}} options of service creation functions. These
options expect values of type <<a_api | type
Eliom_parameters.params_type >> that represent the set of expected
arguments with their types. They are build using combinator from the
<<a_api | module Eliom_parameters >> module. See chapter <<a_manual
chapter="params"| Service parameters >> for a detailled description of
this module.

The type informations associated to each argument allows Eliom to
automatically convert the actual parameters into the corresponding
OCaml types. If the parameter can't be converted, the exception
<<a_api | exception Eliom_common.Eliom_Typing_Error >> is raised.
<<wip-inline| See ... on how to handle this exception. >>



==== Service scopes ====

It is possible to set a scope for services. Either you want a
(co)-service to be visible only for one user (or one client-side
process, or one session), or you want to define specialized version of
some global services. If you register several time a service with
several scopes, Eliom will try the service in increasing scope order
(that is, first the client process service if any, then session, then
session group, then global).

To limite the scope of a service, just add the argument {{{~scope}}}
to the <<a_api | val Eliom_output.Html5.register>> function (or other
{{{register}}} variants: <<a_api | val Eliom_output.Xhtml.register>>,
...). The default scope is <<a_api | val Eliom_common.global>>.



====@@id="get_and_post"@@ GET services and POST services ====

Regular services, attached and non-attached coservices all come in two
versions, GET service or POST service, corresponding to the HTTP
method you want to be used to call them.

* The GET method is intended to be used to retrieve a document from
  the server. The page is generated mainly according to the
  information contained in the URL.  URLs may contain parameters
  (consisting of name-value pairs in the URL string), and these
  parameters may come from HTML forms (or not).
* The POST method is used to send data to the server (files, for
  example), but also values coming from an HTML form. Data is sent in
  the body of the HTTP request. It is possible to use the POST method
  with an empty body.

In HTML, it is not possible to mix GET and POST parameters in forms,
but it is possible to use a POST form with (fixed) GET parameters in
the URL.

<<concept

  title="POST or GET?" |

  POST and GET methods are not equivalent, and you must be very
  careful if you want to use one or the other. Remember that only GET
  services are bookmarkable. The HTTP method and POST parameters are
  not stored in bookmarks.

  * Use the GET method if you want the user to be able to come back to
    the service later or to write the URL manually.
  * Use the POST method for //hidden service//, that is when you want
    a different behaviour between the first click and a reload of the
    page. Usually using POST method triggers an action on server side
    (like a payment, or adding something in a database), and you don't
    want it to succeed several times if the page is reloaded or
    bookmarked.

>>








===@@id="regular_services"@@ Regular services ===

Regular services with GET method are the main entry points of
sites. They correspond to actual URLs and may be bookmarked. The other
kinds of services (POST, coservices) are using the URL of existing
regular GET services.

Regular services are created using the function <<a_api | val
Eliom_services.service>>.

POST services must be accessible even when the request was done
without the POST parameters (for instance, when typing the URL in the
browser, reloading, using bookmarks,~ ...). Hence every POST service
has a //fallback// GET service.

POST services are created using <<a_api | val
Eliom_services.post_service>>.

<<concept

  title="URLs and ergonomics of your Web site"|

  While designing a Web site, one of the first things to think about
  are the URLs you want to use.  URLs are the entry points for your
  site. Assume that they will be bookmarked.

  Eliom has a very precise management of URLs, and let you choose
  exactly the URLs and parameter names you want. Parts of the path may
  also be used as parameters.

  Avoid dummy URLs that will always perform a redirection.  Be very
  careful about the HTTP method you are using.  Use clearly readable
  URLs.

  And be very attentive to the ergonomics of your Web site!  The
  different kinds of services offered by Eliom make possible all the
  precise behaviours you need!

>>

<<concept

  title="Priority of regular services"|

  When creating a regular service you can add the optional {{{int}}}
  parameter {{{~priority}}} to set the priority of the service.  The
  default priority is 0. Services with higher priority will be tried
  by Eliom before the ones with lower priority.  Use this when several
  services are configured to respond to the same request.  This can
  happen for instance when using <<a_manual chapter="params"
  fragment="suffix" | suffix parameters>>.

>>



===@@id="attached_coservices"@@ Attached coservices ===

GET attached coservices are created using function <<a_api| val
Eliom_services.coservice>>.

Anonymous GET attached coservices are often created dynamically with
respect to previous interaction with the user (e.g. filling forms in
multiple steps). They handle correctly the classical web interactions
("back" button, bookmark, tab,~ ...): you create a new coservice each
time you want to record a precise point in the interaction with a
user, to be able to come back there later.

Often, they should be used with a restricted scope (see the section
<<a_manual chapter="state" fragment="service_scope"| Scope of
services>>).

POST attached coservices are created using <<a_api| val
Eliom_services.post_coservice>>.

They can be used to customize the behaviour of an URL.  Some of their
usages are:

* For the same purpose as GET coservices but when you don't want this
  service to be bookmarkable.
* For performing side effects before serving a page.  For example say
  you want a disconnection button that leads to the main page of the
  site, but with the side effect of disconnecting the user.  You will
  use a (named) POST (attached) coservice.

If a coservice does not exist anymore (e.g. if its timeout has expired
or the session to which it belongs was closed ... ), the fallback is
called.

The fallback of a GET coservice cannot take parameters. But
it is possible to use a <<a_manual chapter="services"
fragment="preapplied" | pre-applied>> service as fallback.


===@@id="non-attached_coservices"@@Non-attached coservices ===

Non-attached coservices are coservices that are not attached to an URL
path.  Service identification is performed only according to the
coservice identifier, whatever be the path.  When you point a link or
a form towards such a service, the URL path and the main parameters do
not change.  The parameters of the non-attached coservice are sent as
special parameters.

To create a non-attached coservice, use <<a_api| val
 Eliom_services.coservice'>> or <<a_api| val
 Eliom_services.post_coservice'>> (note the "prime" at the end).

Use POST non-attached coservices for example if you want a link or
form to be present on every page but you don't want the URL to change
when the link is followed. Typically, non-attached POST coservices are
used with <<a_manual chapter="outputs" fragment="actions"|actions>> or
<<a_manual chapter="outputs" fragment="redirections"|redirections>>.

Here is one simple example. Suppose you wrote a function <<code-inline
language="ocaml"|remove>> to remove one piece of data from a database
(taking an identifier of the data).  If you want to put a link on your
page to call this function and redisplay the page, just create an
action on a non-attached coservices like this:

<<code language="ocaml"|

let remove_action =
  Eliom_output.Action.register_post_coservice'
    ~post_params:(Eliom_parameters.int "id")
    (fun () id -> remove id)

>>

Then wherever you want to add a button to do that action (on data
{{{id}}}), create a form like:

<<code language="ocaml"|

Eliom_output.Html5.post_form remove_action
  (fun id_name ->
     Eliom_output.Html5.int_input
       ~input_type:`Hidden ~name:id_name ~value:id ();
     Eliom_output.Html5.string_input
       ~input_type:`Submit ~value:("remove "^string_of_int id) ())

>>



=== Common options for coservices ===

==== Timeouts for coservices =====

It is possible to use timeouts with coservices using the optional
parameter {{{?timeout}}} of creation functions.  For example if your
coservice is here to show the results of a search, you probably want
it to be available only for a short time. The following example shows
a coservice with timeout.

//Warning:// forgetting timeouts may cause memory leaks!


==== Disposable coservices ====

It is possible to set a limit to the number of uses of (attached or
non-attached) coservices. Just give the maximum number of uses with
the optional {{{?max_use}}} parameter while creating your
coservices. Example




==@@id="unregistrable_services"@@ Unregistrable services ==

<<outline depth="2" >>

===External services===

It is possible to define external services, that is, services that
belong to an external Web site (on the same server of not).  To do
that, use the functions <<a_api| val Eliom_services.external_service
>> (for using the GET method), or <<a_api| val
Eliom_services.external_post_service>> (for using the POST method).

For example, the follwing code defines a link to the OCaml Wikipedia
page:

<<code language="ocaml"|

Eliom_output.Html5.a
  (Eliom_services.external_service
     ~prefix:"http://en.wikipedia.org"
     ~path:["wiki";""]
     ~get_params:(suffix (all_suffix "suff"))
     ())
  [pcdata "OCaml on wikipedia"]
  ["OCaml"]

>>

===@@id="staticparts"@@ Static files service===

<<a_manual project="ocsigenserver" chapter="staticmod" | Staticmod>>
is an Ocsigen Server extension serving static (non-generated) files
(for examples images and stylesheets). It can be used together with
Eliom. The predefined service <<a_api| val Eliom_services.static_dir
>> can be used to make links to static files. It takes as parameter
the path of the file.

For example, the followin code will create this link: [[site:ocsigen10.png|download image]].

<<code language="ocaml"|

a (static_dir ()) [pcdata "download image"] ["ocsigen10.png"]

>>

It is also possible to send static files using Eliom, with <<a_api|
module Eliom_output.Files>> (see <<a_manual chapter="outputs"
fragment="eliomfiles" |Sending files>>).



===@@id="preapplied"@@Pre-applied services

It is possible to preapply the GET parameters of a service to obtain a
service without parameters, or only the POST ones. It is done using
<<a_api |val Eliom_services.preapply>>. Example:

<<code language="ocaml"|

let some_service =
  Eliom_services.service ~path:["serv"]
    ~get_params:Eliom_parameters.int ()

let preappl = Eliom_services.preapply some_service 3

>>

It is not possible to register a handler on a preapplied service, but
you can use them in links or as fallbacks for coservices.


===@@id="void"@@Void coservices

<<a_api| val Eliom_services.void_coservice'>> is a special
non-attached action, with special behaviour: it has no parameter at
all, even non-attached parameters.  Use it if you want to make a link
to the current page without non-attached parameters.  It is almost
equivalent to a POST non-attached coservice without POST parameters,
on which you register an action that does nothing, but it is using GET
method, so that you can use it with <<span class="code"|<a>>> links,
not only forms.  Example:

<<code language="ocaml"|

a Eliom_services.void_coservice' [pcdata "cancel"] ()

>>

There is also <<a_api| val Eliom_services.https_void_coservice'>>
(same, but forces use of HTTPS), <<a_api| val
Eliom_services.void_hidden_coservice'>>, and <<a_api| val
Eliom_services.https_void_hidden_coservice'>>. "Hidden" means that
they keep GET non attached parameters.

Use <<a_api| val Eliom_services.void_hidden_coservice'>> for example
after a POST request if you want to do a redirection towards the same
page without POST parameters (and thus prevent from reposting data if
the user reloads the page).

<<wip|Example: link to fragment of the current page>>

