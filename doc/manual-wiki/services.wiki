=Services=

<<wip|
The documentation is now mostly complete, but we are still working on it
(some parts need to be reworked, some small parts are missing).
We will release it as a PDF book in a few week.
Any help appreciated.>>
<<wip|Some links and ref are currently broken.>>

From this chapter to the remainder of the book, we assume you've read the
[[wiki(36):|Ocsigen framework tutorial]] which gives an overview of
the whole project and explains the main concepts. In particular, we suppose
you have basic knowledge on how to define services with parameters,
create links and forms, and use Eliom references.

Each chapter in this part concentrates on a particular Eliom concept, going into full detail.
They can be read in any order, according to your needs.

==General principles==

<<concept title="Services"|

Eliom web pages are identified by services. Services are identifiers
used to create hyperlinks. It contains more information that an URL,
it also defines which type of parameter a page has, and how they are
encoded. Services are created using functions from
<<a_api | module Eliom_services>>

For instance:

<<code language="ocaml"|
let service = Eliom_services.service
  ~path:["path"]
  ~get_params:(Eliom_parameter.string "parameter name")
  ()
>>

And to create a link to {{{service}}}:

<<code language="ocaml"|
a ~service [pcdata "link content"] "service parameter"
>>

See <<a_manual chapter="services" fragment="registerable_services"| more>>
>>

<<concept title="Registration of service handlers"|

To serve pages, we have to associate some content to services. This
association is what we call //registration//. The registration inform
the <<a_manual chapter="services" fragment="mechanism"|service identification mechanism>>
to associate a function (known as a //service handler//) to a service.
Then, if a user follows a link to a service, the content of the page
is provided by the registered service handler. The parameters of the
handler are provided by the link.

Services are registered using the {{{Eliom_output.*.register}}}
functions. The registration function to use depend on the type of
content a handler is generating. For instance, a page containing HTML5
is registered using <<a_api | val Eliom_output.Html5.register>>:

<<code language="ocaml"|
Eliom_output.Html5.register
  ~service
  (fun param () ->
     Lwt.return (html (head (title (pcdata "")) [])
       (body [h1 [pcdata ("service called with parameter" ^ param)]])))
>>

Certain services can be registered multiple times with different
options. This allows to choose between different handlers when the
request is done in a particular session or protocol (HTTP or HTTPS).

See <<a_manual chapter="services" fragment="service_registration"| more>>
>>

==@@id="registerable_services"@@ Registerable services ==

There are 3 kind of services that can be registered:

* <<a_manual chapter="services" fragment="main_services" | Main services >> are the main entry points of sites.
  They correspond to classical URLs, and will last forever.

* <<a_manual chapter="services" fragment="attached_coservices" | Attached coservices >>
  are services that share their
  location (URL) with a main service (fallback).
  They are distinguished from that main service using a special parameter
  (added automatically by Eliom). They can be created dynamically. When
  an attached coservice is not available anymore ( timeout, session closed, ... )
  it fallbacks to the main service.

* <<a_manual chapter="services" fragment="non-attached_coservices" | Non-attached coservices >>
  are coservices that are not attached to a particular URL. A link to a
  non-attached coservice will go to the current URL with a special
  parameter. It is useful when you want the same link or form on
  several pages (for example a connection box) but you don't want to go to another
  URL. Non-attached coservices are often used with
  <<a_manual chapter="outputs" fragment="actions" |actions>>.

===@@id="get_and_post"@@GET and POST methods===

The registerable service creation functions come in two version:
Served with GET or POST HTTP methods:

* The GET method is intended to be used to retrieve a document
from the server. The page is generated mainly according to the information
contained in the URL.  URLs may contain parameters (consisting of name-value pairs in the URL string), and these parameters
may come from HTML forms.
* The POST method is used to send data to the server (files, for example),
but also values coming from an HTML form. Data is sent in the body of the HTTP
request. It is possible to use the POST method with an empty body.

The parameters of services are specified using the {{{~get_params}}}
and {{{~post_params}}} options of service creation functions. The parameter
descriptions are build using functions from <<a_api | module Eliom_parameters>>.
More informations <<a_manual chapter="params" | here >>.

In HTML, it is not possible to mix GET and POST parameters in forms, but it
is possible to use a post service with its get parameters pre-applied on
server side (see <<a_manual chapter="services" fragment="preapplied" |here>>).

<<concept title="POST or GET?" |
POST and GET methods are not equivalent, and you must be very careful
if you want to use one or the other.\\

Remember that only GET services are bookmarkable. The HTTP method and
POST parameters are not stored in bookmarks.\\
Use the GET method if you want the user to be able to come back to the service
later or to write the URL manually.\\
Use the POST method for //hidden service//, that is when you want a
different behaviour
between the first click and a reload of the page. Usually using
POST method triggers an action on server side
(like a payment, or adding something in a database), and you don't want
it to succeed several times if the page is reloaded or bookmarked.
>>

===@@id="main_services"@@Main services===

Main services with GET method are the main entry points of sites. They
correspond to real URL: the other kind of services (POST, coservices)
are using the URL of existing main GET services.

They are created using the functions <<a_api | val Eliom_services.service>>.

POST services must be accessible even when the request was done without the POST
parameters ( for instance, when typing the URL in the browser, reloading,
using bookmarks, ... ). Hence every POST service has a //fallback// GET service.

POST services are created using <<a_api | val Eliom_services.post_service>>.

====Priority of main services

When creating a main service you can add the optional
{{{int}}} parameter {{{~priority}}} to set the priority of the service.
The default priority is 0. Services with higher priority
will be tried by Eliom before the ones with lower priority.
Use this when several services are configured to respond to the same request.
This can occur for instance when using
<<a_manual chapter="params" fragment="suffix" | suffix parameters>>

<<concept title="Paths" |

<<span class="code"|["foo"; "bar"]>> corresponds to the URL
<<span class="code"|foo/bar>>.  \\
<<span class="code"|["dir"; ""]>> corresponds to the URL <<span class="code"|dir/>>
(that is: the default page of the directory <<span class="code"|dir>>).   \\
The empty list <<span class="code"|[]>> is equivalent to <<span class="code"|[""]>>.\\

//Warning://
You cannot create a service on path <<span class="code"|["foo"]>>
(URL <<span class="code"|foo>>, without slash at the end)
and another on path <<span class="code"|["foo";"bar"]>>
(URL <<span class="code"|foo/bar>>) because <<span class="code"|foo>> can not be
both a directory and a file.
Be also careful not to use a path as a directory with
Eliom, if it is a file for Staticmod (and vice versa).

//Warning://
<<span class="code"|["foo";"bar"]>> is not equivalent to
<<span class="code"|["foo/bar"]>>.
In the latter, the "/" will be encoded in the URL.\\

The following example shows how to define the default page for
a directory.
<<code language="ocaml"|
let default = Eliom_output.Html5.register_service ["rep";""] unit
  (fun () () ->
    Lwt.return
     (html
      (head (title (pcdata "")) [])
      (body [p [pcdata "default page. rep is redirected to rep/"]])))
>>

>>

==@@id="coservices"@@Coservices

Coservices are services that are not directly associated with an
URL. They can either be associated to an existing main service
(<<a_manual chapter="services" fragment="attached_coservices"|attached
coservices>>)or to the service serving the current URL (<<a_manual
chapter="services" fragment="non-attached_coservices"|non-attached
coservices>>).

Coservices can be used to customize the behaviour of an URL service
depending on the situation. They can be created and registered
<<a_manual chapter="services" fragment="dynamic_services"| dynamically>>

When requesting coservices the <<a_manual chapter="services"
fragment="mechanism"|service identification mechanism>> find them
using their identifier. By default those are randomly ( non guessable
) chosen, but they can be specified, at the service creation, using
the {{{~name}}} parameter. Coservice with generated name are called
//anonymous//. Note that anonymous coservice identifiers will be
different each time the server is restarted.

===@@id="attached_coservices"@@Attached coservices

GET attached coservices are often created dynamically with respect to
previous interaction with the user (e.g. filling forms in multiple
steps). They handle correctly the classical web interractions ("back"
button, bookmark, tab, ...). Often, they should be used with a
restricted scope (see the section <<a_manual chapter="state"
fragment="service_scope"| Scope of services >>).

GET attached coservices are created using <<a_api| val Eliom_services.coservice >>.

POST attached coservices can be used to customize the behaviour of an url.
Some of their usages are:
* For the same purpose as GET coservices but when you don't want this service to be bookmarkable.
* For preforming side effects before serving a page ( e.g. login in or out of a site before
going to the fallback page ). It is often done using redirections.

POST attached coservices are created using <<a_api| val Eliom_services.post_coservice >>.

If a coservice does not exist anymore (e.g. if its timeout
has expired or the session was closed ... ), the fallback is called.

Note that the fallback of a GET coservice cannot take parameters. But
it is possible to use a <<a_manual chapter="services"
fragment="preapplied" | pre-applied>> service as fallback


===@@id="non-attached_coservices"@@Non-attached coservices

Non-attached coservices are coservices that are not attached to an URL path.
Service identification is performed only according to the coservice
identifier, whatever be the path.
When you point a link or a form towards such a service, the URL path
and the main parameters do not change.
The parameters of the non-attached coservice are sent as special parameters.

To create a non-attached coservice, use
 <<a_api| val Eliom_services.coservice' >> or
 <<a_api| val Eliom_services.post_coservice' >>
(note the "prime" at the end).

POST non-attached coservices are useful if you want a
link or form to be present on every page but you don't want the
URL to change when the link is followed. Typically, non-attached POST coservices are
used with <<a_manual chapter="outputs" fragment="actions"|actions>> or <<a_manual chapter="outputs" fragment="redirections"|redirections>>.

Here is one simple example. Suppose you wrote a function
<<span class="code"|remove>> to remove one piece of data from a database
(taking an identifier of the data).
If you want to put a link on your page to call this function
and redisplay the page, just create an action on a non-attached coservices
like this:

<<code language="ocaml"|let remove_action =
  Eliom_output.Action.register_post_coservice'
    ~post_params:(Eliom_parameters.int "id")
    (fun () id -> remove id)
>>

Then wherever you want to add a button to do that action
(on data <<span class="code"|id>>), create a form like:

<<code language="ocaml"|Eliom_output.Html5.post_form remove_action
  (fun id_name ->
     Eliom_output.Html5.int_input
       ~input_type:`Hidden ~name:id_name ~value:id ();
     Eliom_output.Html5.string_input
       ~input_type:`Submit ~value:("remove "^string_of_int id) ())
>>

===Common options for coservices

====Timeouts for coservices

It is possible to use timeouts with coservices using
the optional parameter {{{?timeout}}} of creation functions.
For example if your coservice is here to show the
results of a search, you probably want it to be available only for
a short time. The following example shows a coservice with timeout.

<<code language="ocaml"|let timeout = service ["timeout"] unit ()

let _ =
  let page () () =
    let timeoutcoserv =
      Eliom_output.Html5.register_coservice
        ~fallback:timeout
        ~get_params:unit
        ~timeout:5.
        (fun _ _ ->
           Lwt.return
             (html
               (head (title (pcdata "Coservices with timeouts")) [])
               (body [p
                 [pcdata "I am a coservice with timeout."; br ();
                  pcdata "Try to reload the page!"; br ();
                  pcdata "I will disappear after 5 seconds of inactivity." ];
                 ])))
    in
    Lwt.return
      (html
        (head (title (pcdata "Coservices with timeouts")) [])
        (body [p
          [pcdata "I just created a coservice with 5 seconds timeout."; br ();
           a timeoutcoserv [pcdata "Try it"] (); ];
          ]))
  in
  Eliom_output.Html5.register timeout page
>>


====Disposable coservices

It is possible to set a limit to the number of uses of
  (attached or non-attached) coservices. Just give the maximum number
  of uses with the optional {{{?max_use}}} parameter while
  creating your coservices. Example

<<code language="ocaml"|let disposable = service ["disposable"] unit ()

let _ = register disposable
(fun () () ->
      let disp_coservice =
        coservice ~max_use:2 ~fallback:disposable ~get_params:unit ()
      in
      register ~scope:`Session ~service:disp_coservice
        (fun () () ->
          return
            (html
              (head (title (pcdata "")) [])
              (body [p [pcdata "I am a disposable coservice";
                        br ();
                        a disp_coservice [pcdata "Try me once again"] ()]]))
        );
      return
        (html
          (head (title (pcdata "")) [])
          (body [p [(if Eliom_request_info.get_link_too_old ()
                    then pcdata "Your link was outdated. I am the fallback.
		                 I just created a new disposable coservice.
		                 You can use it only twice."
                    else
                    pcdata "I just created a disposable coservice.
		            You can use it only twice.");
                    br ();
                    a disp_coservice [pcdata "Try it!"] ()]])))
>>


==@@id="service_registration"@@Service registration==

The registration associate services to //service handlers// generating
its content. Registration functions are specific to the type of
content the service handler generate. Here we will explain what is
common to all registrations. Fore more information see the
chapter on <<a_manual chapter="outputs"|Predefined registration
modules>>.

===@@id="scope"@@Scope of services===

By default, services and coservices are accessible to anybody.  It is
possible to restrict the //scope// of a service, making it available
only to a session, a client side process, or a group of sessions (see
<<a_manual chapter="state"|chapter on sessions>> for more information
on scopes).

The same service can be registered with several scopes.
This makes it possible, for example, to generate custom services for a specific user.
Eliom will try to find the service by trying the following (in order):
* scope client-side process,
* scope session,
* scope group of session, and
* global scope.

If the service has not been found, and it is a coservice, it will then
try the fallback, in the same scoping order.

To set the scope of a service registration, add the optional
parameter {{{~scope}}} to the {{{register}}} function.

<<concept title="Tips and advices" |

* All services created during initialization must be registered
(with global scope) during the initialization phase of your module.
If not, the server will not start (providing  an appropriate error message in the logs).
This will prevent broken links.

* Services may be registered only during the server's initialization phase
(while reading the site configuration) or while processing a request,
because Eliom must know the information about the site. Be very careful
about this if you want to use static linking (see the section on
<<a_manual chapter="config" fragment="static_linking"|static linking>> in the chapter about Compiling and configuring Eliom modules).

* All main services (but not coservices) must be created in a module loaded
inside a {{{<host>}}} tag of the configuration file.
It is not possible to accomplish this using modules loaded inside
{{{<extension>}}} or {{{<library>}}}.

* If you create new main services dynamically,
you will dynamically create new URLs!
This may be dangerous as they will disappear if you stop the server.
Be very careful to re-create these URLs when you relaunch the server,
otherwise, some external links or bookmarks will be broken!\\
The use of that feature is discouraged for coservices
without timeout, as such coservices will be available only until the end
of the server process (and it is not possible to re-create them with the
same key).

*Do not register the same service (with scope global) twice,
and do not replace a service
by a directory (or vice versa). If this happens during the
initialization phase, the server won't start.
If this happens after server startup, it will be ignored (with a warning in the
logs).

*GET coservices (without POST parameters) can be registered
only with a main service without GET/POST parameters as fallback.
But it may be a
<<a_manual chapter="services" fragment="preapplied" |//preapplied//>>.

*Services with POST parameters (main service or coservice)
can be registered with a (main or co-) service without POST
parameters as fallback.
*The registration of (main) services must be completed before
the end of the loading of the module. It is not possible to launch
a (Lwt) thread with the intention that it will register a service later, as
registering a service needs access to config file
information (for example the directory of the site).
If you do this, the server will raise
<<a_api | exception Eliom_common.Eliom_function_forbidden_outside_site_loading >>
most of the time,
but you may also get unexpected results (if the thread is executed
while another site is loaded).
If you use threads in the initialization phase of your module
(for example if you need information from a database),
use  <<a_api project="lwt" | val Lwt_unix.run >> to wait the end of the thread.
>><<|concept>>

== Security ==

Il y a plusieurs propriete que l'on peut gerer automatiquement dans eliom:

On ne veut pas que les information d'un utilisateur soient decouvertent:
ecoute le trafic: https
se connecter a un service qui n'a pas ete cree pour un utilisateur: coservice anonyme, cookies
faire faire une action a un utilisateur sans son consentement: crsf, xss, clickjacking

Here are ways to protect against some common attacks.

* information stealing, by listening to the connection:\\
  if the connection is not cyphered, the content of the HTTP
  request and answers will be eavesdroppable. The eliom options for
  handling https are:
** Set the {{{~https}}} option of services: all links to that service will be using https scheme. Note
   that in case of a man in the middle rewritting the https url to http ones, even when the page is
   not available in http, the browser will send its informations before receiving the error. Then
   the man in the middle could get the information and replay the request.
** Set the {{{~secure_session}}} option at service registration: when the scope is not of level global,
   this register the sevices to a session table which is available only when secure cookies are available:\\
   Secure cookies are cookies sent only over https: this means that if there is a man in the middle attack
   serving https content as http to the user, the browser won't send secure cookies and the server
   won't serve the page. Note that it won't protect for an attack on the first connection
   ( when the cookie is set ).
** It is also possible to limit connections to https in the configuration of ocsigenserver:
   see the manual of the <<a_manual project="ocsigenserver" chapter="accesscontrol"|accesscontrol extension>>

* Access to other user's services:
** By default coservices are generated with non guessable id ( cryptographically secure random numbers ).
   Note that when setting the {{{~name}}} parameter of coservices, this is not the case.
** services can be registered inside a given scope. This will be accessible only to
   the browser inside the scope: with the right cookies.

* Protection against Cross Site Request Forgery: See below

* Protection against ClickJacking:
** set the "X-Frame-Options" header using the {{{~headers}}} option of register functions for setting it to
   a single service. For setting it to the whole site see the
   <<a_manual project="ocsigenserver" chapter="outputfilter"|outputfilter>> extension of ocsigenserver.

====HTTPS links

If the protocol needs to be changed (from HTTP to HTTPS
or vice versa), Eliom will generate absolute URLs.
The host name and port numbers are guessed from the IP and the
configuration by default, but it is recommended to specify them
in the configuration file. For example:

<<div class="pre"|<host hostfilter="*.org" defaulthostname="www.mywebsite.org"
defaulthttpport="8080" defaulthttpsport="4433">
  ...
</host>
>>

===HSTS

For now, it is possible to set The "Strict-Transport-Security" header
by hand and add a redirection from http version to https versions of
pages, either using eliom redirections, or using the <<a_manual
project="ocsigenserver" chapter="redirectmod"|Redirectmod>> extension
of ocsigenserver.

<<wip|Future version of ocsigen will allow a simpler mechnism>>

===@@id="csrf"@@CSRF-safe services

Eliom implements a protection against CSRF attacks.

====What is CSRF?====

CSRF means //Cross Site Request Forgery//.
Here is an explanation from Wikipedia:

For example, one user, Bob, might be browsing a chat forum where another user,
Mallory, has posted a message. Suppose that Mallory has crafted an HTML image
element that references a script on Bob's bank's website (rather than an image
file), e.g.,\\
<<code language="html"|<img src="http://bank.example/withdraw?account=bob&amount=1000000&for=mallory"> >>
If Bob's bank keeps his authentication information in a cookie, and if the
cookie hasn't expired, then the attempt by Bob's browser to load the image
will submit the withdrawal form with his cookie, thus authorizing a
transaction without Bob's approval.

====Solution without {{{~csrf_safe}}} option====

There is an easy way to protect a service from such attacks:
just create a new anonymous coservice with timeout each time you display the
form. Thus, a new token will be created for each form and no service will
answer if you do not send it (or more precisely, the fallback will).


====CSRF-safe services====

In order to simplify this, Eliom add this possibility:

* When creating a new coservice, you can give the optional
  {{{~csrf_safe}}} parameter
* If this parameter is {{{true}}}, actual registration of the service
  will be delayed and performed each time a form is created that
  points to this coservice.

Example:
<<code language="ocaml"|
let csrfsafe_example =
  Eliom_services.service
    ~path:["csrf"]
    ~get_params:Eliom_parameters.unit
    ()

let csrfsafe_example_post =
  Eliom_services.post_coservice
    ~csrf_safe:true
    ~csrf_secure:true
    ~timeout:10.
    ~max_use:1
    ~https:true
    ~fallback:csrfsafe_example
    ~post_params:Eliom_parameters.unit
    ()

let _ =
  let page () () =
    let l3 = Eliom_output.Xhtml.post_form csrfsafe_example_post
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"Click" ()]]) ()
    in
    Lwt.return
      (html
       (head (title (pcdata "CSRF safe service example")) [])
       (body [p [pcdata "A new coservice will be created
                         each time this form is displayed"];
              l3]))
  in
  Eliom_output.Xhtml.register csrfsafe_example page;
  Eliom_output.Xhtml.register csrfsafe_example_post
    (fun () () ->
       Lwt.return
         (html
            (head (title (pcdata "CSRF safe service")) [])
            (body [p [pcdata "This is a CSRF safe service"]])))

>>

If you register the service with global scope, the CSRF-safe service
will be available for everybody.  However, the actual (delayed)
registration will take place with a restricted scope (default:
{{{Eliom_common.session}}}), described by {{{?csrf_scope}}} and
{{{?csrf_secure}}} (corresponding to {{{?scope}}} and {{{?secure}}}).

If you use {{{register ~scope:Eliom_common.session}}}, the coservice
will be available only for one session. The actual registration will
take place in the same session table, described by {{{?csrf_secure}}}.
In that case, the parameter {{{?secure}}} of {{{register}}} must be
exactly the same.

== Choosing the right services for each case ==

The most commonly used services are:

* Main services (GET or POST) (with global scope) for public
pages.
* GET attached coservices in session service table to make the
browser's "back" button actually move to a previous step or page in the user's interaction,
and to allow several tabs on different versions of the same page
(several steps interaction).
* Actions registered on POST named non-attached coservices
to cause an effect
on the server, from any page, and without changing the URL
(login/logout, for example).

Here is a list of frequent Web interaction issues
and the solution Eliom provides to solve them.

==== Add a login/logout box on each page of your site

For instance, if we are writing a site where some pages are accessible
only to some users, when clicking on a link that lead to that page,
the user would be asked its login and password. When he enter them, he
should be directed to the page he originaly requested.

To do that you should:

* Create a login and a logout non-attached named POST coservices, and
  register an <<a_manual chapter="outputs" fragment="actions"|action>>
  with a function adding or removing some state telling that the user
  is connected.

* Define a customized registration module, which check if a user has
  the rights to se a page before displaying it, using
  <<a_api | module Eliom_output.Customize>>

A detailed example is available in the <<a_manual project="tutorial" chapter="interaction"|tutorial>>

==== Add something to a shopping basket
Use an action registered on a non-attached coservice,
with the names of the items as parameters. The action saves the shopping
basket in an eliom reference (scope {{{`Session}}}).
Thus, the shopping basket will remain
even if the user pushes the "back" button of his browser.

==== Book a ticket (in several steps)
Each step creates new (GET) coservices (with or without
parameters, all attached to the service displaying the main
booking page)
according to the data entered by the user. These
coservices are registered with scope {{{`Session}}} (with a timeout for
the whole session or for each of them). Thus the user can go back
to a previous state, or keep several proposals on different
tabs before choosing one.

<<wip| Add more examples >>

== Predefined and special services ==

===External services===

It is possible to define external services, that is, services that belong
to an external Web site (on the same server of not).
To do that, use the functions {{{Eliom_services.external_service}}}
(for using the GET method),
or {{{Eliom_services.external_post_service}}}
(for using the POST method).

<<wip| Example>>

===@@id="staticparts"@@ Static files service===

<<a_manual project="ocsigenserver" chapter="staticmod" | Staticmod>>
is an Ocsigenserver extension serving static (non-generated) files
(for examples images and stylesheets). It can be used together with
Eliom. The predefined service <<a_api| val Eliom_services.static_dir
>> can be used to make links to static files. It takes as parameter
the path of the file.  \\

For example
<<code language="ocaml"|a (static_dir ()) [pcdata "download image"] ["ocsigen10.png"]
>>
creates this link: [[site:ocsigen10.png|download image]]

It is also possible to send static files using Eliom, with
<<a_api| module Eliom_output.Files>>
(<<a_manual chapter="outputs" fragment="eliomfiles" |see later>>).

===@@id="preapplied"@@Pre-applied services

It is possible to preapply the GET parameters of a service to obtain a
service without parameters, or only the POST ones. It is done using
<<a_api |val Eliom_services.preapply>>. Example:

<<code language="ocaml"|
let some_service =
  Eliom_services.service ~path:["serv"]
    ~get_params:Eliom_parameters.int ()

let preappl = Eliom_services.preapply some_service 3
>>

It is not possible to register a handler on a preapplied service, but
you can use them in links or as fallbacks for coservices.

===@@id="void"@@Void coservices

<<a_api| val Eliom_services.void_coservice' >>
is a special non-attached action, with special behaviour:
it has no parameter at all, even non-attached parameters.
Use it if you want to make a link to the current page
without non-attached parameters.
It is almost equivalent to a POST non-attached coservice without POST
parameters, on which you register an action that does nothing,
but it is using GET method, so that you can use it with
<<span class="code"|<a>>> links, not only forms.
Example:

<<code language="ocaml"|
a Eliom_services.void_coservice' [pcdata "cancel"] ()
>>

There is also
 <<a_api| val Eliom_services.https_void_coservice' >>
(same, but forces use of HTTPS),
 <<a_api| val Eliom_services.void_hidden_coservice' >>, and
 <<a_api| val Eliom_services.https_void_hidden_coservice' >>. "Hidden" means that they keep GET non attached parameters.

Use <<a_api| val Eliom_services.void_hidden_coservice' >> for example
after a POST request
if you want to do a redirection towards the same page without POST parameters
(and thus prevent from reposting data if the user reloads the page).

<<wip|Example>>

== Error handling ==

<<wip| Really here ? >>

=== Exception handling

You can catch the exceptions raised during page generation in two places:

* add an exception handler to services using the
  {{{?error_handler}}} parameter of the registration functions.

* add a global exception handler using <<a_api |
  Eliom_output.set_exn_handler>>

<<code language="ocaml"|
You can use it to catch <<a_api | Eliom_common.Eliom_404>> and
generate a custom 404 page.

<<code language="ocaml"|
let _ = Eliom_output.set_exn_handler
   (fun e -> match e with
    | Eliom_common.Eliom_404 ->
        Eliom_output.Html5.send ~code:404
          (html
             (head (title (pcdata "")) [])
             (body [h1 [pcdata "Eliom tutorial"];
                    p [pcdata "Page not found"]]))
    | Eliom_common.Eliom_Wrong_parameter ->
        Eliom_output.Html5.send
          (html
             (head (title (pcdata "")) [])
             (body [h1 [pcdata "Eliom tutorial"];
                    p [pcdata "Wrong parameters"]]))
    | e -> fail e)
>>

===@@id="infofallbacks"@@ Fallback services

You can check wether a service was directly called or if it was used
as a fallback using the <<a_api| val
Eliom_request_info.get_link_too_old >> function. In case of coservices
registered with a restricted scope, you can check which session was
closed using <<a_api| val
Eliom_request_info.get_expired_service_sessions >>

=== Error in services handlers of actions

If something bad hapen during an action, it is possible to tell the
service generating the page. For instance if you create user accounts
using actions. When the creation fail you may want to display some
message to the user, like "password too weak" or "name already
used". To transmit that kind of information, use eliom references (see
module <<a_api | module Eliom_references>>) created using scope
<<a_api | Eliom_common.request>>, the value will be available to the
service generating the page.
